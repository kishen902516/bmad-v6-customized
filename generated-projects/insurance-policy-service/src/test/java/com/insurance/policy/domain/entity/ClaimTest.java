package com.insurance.policy.domain.entity;

import com.insurance.policy.domain.valueobject.ClaimAmount;
import com.insurance.policy.domain.valueobject.ClaimNumber;
import com.insurance.policy.domain.valueobject.ClaimStatus;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.NullSource;

import java.math.BigDecimal;
import java.time.LocalDate;

import static org.assertj.core.api.Assertions.*;

/**
 * Unit tests for Claim domain entity.
 *
 * Tests business logic, validations, and invariant enforcement.
 * No external dependencies - pure domain logic testing.
 *
 * @author Generated by BMAD Spring Boot Clean Architecture Generator
 * @version 1.0
 */
@DisplayName("Claim Entity Tests")
class ClaimTest {

    @Test
    @DisplayName("Should create valid Claim with required fields")
    void shouldCreateValidClaim() {
        // Given
        ClaimNumber claimNumber = ClaimNumber.generate(2025, 1);
        ClaimAmount claimedAmount = ClaimAmount.of(5000.00, "USD");
        LocalDate incidentDate = LocalDate.of(2025, 1, 15);
        String policyId = "POL-2025-000001";

        // When
        Claim claim = new Claim(claimNumber, claimedAmount, incidentDate, policyId);

        // Then
        assertThat(claim).isNotNull();
        assertThat(claim.getClaimNumber()).isEqualTo(claimNumber);
        assertThat(claim.getClaimedAmount()).isEqualTo(claimedAmount);
        assertThat(claim.getIncidentDate()).isEqualTo(incidentDate);
        assertThat(claim.getPolicyId()).isEqualTo(policyId);
        assertThat(claim.getStatus()).isEqualTo(ClaimStatus.SUBMITTED);
        assertThat(claim.getSubmittedDate()).isNotNull();
    }

    @Test
    @DisplayName("Should throw exception when claim number is null")
    void shouldThrowExceptionWhenClaimNumberIsNull() {
        // Given
        ClaimAmount claimedAmount = ClaimAmount.of(5000.00, "USD");
        LocalDate incidentDate = LocalDate.of(2025, 1, 15);
        String policyId = "POL-2025-000001";

        // When / Then
        assertThatThrownBy(() -> new Claim(null, claimedAmount, incidentDate, policyId))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Claim number is required");
    }

    @Test
    @DisplayName("Should throw exception when claimed amount is null")
    void shouldThrowExceptionWhenClaimedAmountIsNull() {
        // Given
        ClaimNumber claimNumber = ClaimNumber.generate(2025, 1);
        LocalDate incidentDate = LocalDate.of(2025, 1, 15);
        String policyId = "POL-2025-000001";

        // When / Then
        assertThatThrownBy(() -> new Claim(claimNumber, null, incidentDate, policyId))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Claimed amount is required");
    }

    @Test
    @DisplayName("Should throw exception when claimed amount is zero")
    void shouldThrowExceptionWhenClaimedAmountIsZero() {
        // Given
        ClaimNumber claimNumber = ClaimNumber.generate(2025, 1);
        ClaimAmount zeroAmount = ClaimAmount.ZERO_USD;
        LocalDate incidentDate = LocalDate.of(2025, 1, 15);
        String policyId = "POL-2025-000001";

        // When / Then
        assertThatThrownBy(() -> new Claim(claimNumber, zeroAmount, incidentDate, policyId))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Claimed amount must be greater than zero");
    }

    @Test
    @DisplayName("Should throw exception when incident date is null")
    void shouldThrowExceptionWhenIncidentDateIsNull() {
        // Given
        ClaimNumber claimNumber = ClaimNumber.generate(2025, 1);
        ClaimAmount claimedAmount = ClaimAmount.of(5000.00, "USD");
        String policyId = "POL-2025-000001";

        // When / Then
        assertThatThrownBy(() -> new Claim(claimNumber, claimedAmount, null, policyId))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Incident date is required");
    }

    @Test
    @DisplayName("Should throw exception when incident date is in the future")
    void shouldThrowExceptionWhenIncidentDateIsInFuture() {
        // Given
        ClaimNumber claimNumber = ClaimNumber.generate(2025, 1);
        ClaimAmount claimedAmount = ClaimAmount.of(5000.00, "USD");
        LocalDate futureDate = LocalDate.now().plusDays(1);
        String policyId = "POL-2025-000001";

        // When / Then
        assertThatThrownBy(() -> new Claim(claimNumber, claimedAmount, futureDate, policyId))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Incident date cannot be in the future");
    }

    @ParameterizedTest
    @NullSource
    @DisplayName("Should throw exception when policy ID is null or empty")
    void shouldThrowExceptionWhenPolicyIdIsNullOrEmpty(String policyId) {
        // Given
        ClaimNumber claimNumber = ClaimNumber.generate(2025, 1);
        ClaimAmount claimedAmount = ClaimAmount.of(5000.00, "USD");
        LocalDate incidentDate = LocalDate.of(2025, 1, 15);

        // When / Then
        assertThatThrownBy(() -> new Claim(claimNumber, claimedAmount, incidentDate, policyId))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Policy ID is required");
    }

    @Test
    @DisplayName("Should move claim to under review status")
    void shouldMoveToUnderReview() {
        // Given
        Claim claim = createValidClaim();

        // When
        claim.moveToUnderReview();

        // Then
        assertThat(claim.getStatus()).isEqualTo(ClaimStatus.UNDER_REVIEW);
    }

    @Test
    @DisplayName("Should approve claim when under review")
    void shouldApproveClaim() {
        // Given
        Claim claim = createValidClaim();
        claim.moveToUnderReview();

        // When
        claim.approve();

        // Then
        assertThat(claim.getStatus()).isEqualTo(ClaimStatus.APPROVED);
    }

    @Test
    @DisplayName("Should throw exception when approving claim not under review")
    void shouldThrowExceptionWhenApprovingClaimNotUnderReview() {
        // Given
        Claim claim = createValidClaim();

        // When / Then
        assertThatThrownBy(claim::approve)
                .isInstanceOf(IllegalStateException.class)
                .hasMessageContaining("Can only approve claims in UNDER_REVIEW status");
    }

    @Test
    @DisplayName("Should reject claim when under review")
    void shouldRejectClaim() {
        // Given
        Claim claim = createValidClaim();
        claim.moveToUnderReview();

        // When
        claim.reject();

        // Then
        assertThat(claim.getStatus()).isEqualTo(ClaimStatus.REJECTED);
    }

    @Test
    @DisplayName("Should throw exception when rejecting claim not under review")
    void shouldThrowExceptionWhenRejectingClaimNotUnderReview() {
        // Given
        Claim claim = createValidClaim();

        // When / Then
        assertThatThrownBy(claim::reject)
                .isInstanceOf(IllegalStateException.class)
                .hasMessageContaining("Can only reject claims in UNDER_REVIEW status");
    }

    @Test
    @DisplayName("Should mark claim as paid when approved")
    void shouldMarkClaimAsPaid() {
        // Given
        Claim claim = createValidClaim();
        claim.moveToUnderReview();
        claim.approve();

        // When
        claim.markAsPaid();

        // Then
        assertThat(claim.getStatus()).isEqualTo(ClaimStatus.PAID);
    }

    @Test
    @DisplayName("Should throw exception when marking non-approved claim as paid")
    void shouldThrowExceptionWhenMarkingNonApprovedClaimAsPaid() {
        // Given
        Claim claim = createValidClaim();

        // When / Then
        assertThatThrownBy(claim::markAsPaid)
                .isInstanceOf(IllegalStateException.class)
                .hasMessageContaining("Can only mark approved claims as paid");
    }

    @Test
    @DisplayName("Should return true when claim can be processed for payment")
    void shouldReturnTrueWhenClaimCanBeProcessedForPayment() {
        // Given
        Claim claim = createValidClaim();
        claim.moveToUnderReview();
        claim.approve();

        // When / Then
        assertThat(claim.canBeProcessedForPayment()).isTrue();
    }

    @Test
    @DisplayName("Should return false when claim cannot be processed for payment")
    void shouldReturnFalseWhenClaimCannotBeProcessedForPayment() {
        // Given
        Claim claim = createValidClaim();

        // When / Then
        assertThat(claim.canBeProcessedForPayment()).isFalse();
    }

    @Test
    @DisplayName("Should return true when claim is in final state")
    void shouldReturnTrueWhenClaimIsInFinalState() {
        // Given
        Claim paidClaim = createValidClaim();
        paidClaim.moveToUnderReview();
        paidClaim.approve();
        paidClaim.markAsPaid();

        Claim rejectedClaim = createValidClaim();
        rejectedClaim.moveToUnderReview();
        rejectedClaim.reject();

        // When / Then
        assertThat(paidClaim.isInFinalState()).isTrue();
        assertThat(rejectedClaim.isInFinalState()).isTrue();
    }

    @Test
    @DisplayName("Should return false when claim is not in final state")
    void shouldReturnFalseWhenClaimIsNotInFinalState() {
        // Given
        Claim claim = createValidClaim();

        // When / Then
        assertThat(claim.isInFinalState()).isFalse();
    }

    @Test
    @DisplayName("Should implement equals and hashCode based on ID")
    void shouldImplementEqualsAndHashCodeBasedOnId() {
        // Given
        Claim claim1 = createValidClaim();
        Claim claim2 = createValidClaim();

        // When / Then
        assertThat(claim1).isNotEqualTo(claim2); // Different instances without ID
    }

    @Test
    @DisplayName("Should have meaningful toString representation")
    void shouldHaveMeaningfulToString() {
        // Given
        Claim claim = createValidClaim();

        // When
        String toString = claim.toString();

        // Then
        assertThat(toString)
                .contains("Claim")
                .contains("claimNumber")
                .contains("claimedAmount")
                .contains("status");
    }

    // Helper method
    private Claim createValidClaim() {
        ClaimNumber claimNumber = ClaimNumber.generate(2025, 1);
        ClaimAmount claimedAmount = ClaimAmount.of(5000.00, "USD");
        LocalDate incidentDate = LocalDate.of(2025, 1, 15);
        String policyId = "POL-2025-000001";
        return new Claim(claimNumber, claimedAmount, incidentDate, policyId);
    }
}
