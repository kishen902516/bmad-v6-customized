package com.insurance.policy.infrastructure.adapter.persistence;

import com.insurance.policy.domain.entity.Claim;
import com.insurance.policy.domain.valueobject.ClaimAmount;
import com.insurance.policy.domain.valueobject.ClaimNumber;
import com.insurance.policy.domain.valueobject.ClaimStatus;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.*;

/**
 * Integration tests for ClaimRepositoryAdapter.
 *
 * Tests repository implementation with real database using TestContainers.
 * Verifies CRUD operations and custom queries.
 *
 * @author Generated by BMAD Spring Boot Clean Architecture Generator
 * @version 1.0
 */
@DataJpaTest
@Testcontainers
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Import(ClaimRepositoryAdapter.class)
@DisplayName("Claim Repository Integration Tests")
class ClaimRepositoryAdapterIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
        registry.add("spring.jpa.hibernate.ddl-auto", () -> "create-drop");
    }

    @Autowired
    private ClaimRepositoryAdapter repository;

    private Claim testClaim;

    @BeforeEach
    void setUp() {
        testClaim = createTestClaim(1, "POL-2025-000001");
    }

    @Test
    @DisplayName("Should save and retrieve Claim")
    void shouldSaveAndRetrieve() {
        // When
        Claim saved = repository.save(testClaim);

        // Then
        assertThat(saved).isNotNull();
        assertThat(saved.getId()).isNotNull();
        assertThat(saved.getClaimNumber()).isEqualTo(testClaim.getClaimNumber());
        assertThat(saved.getClaimedAmount()).isEqualTo(testClaim.getClaimedAmount());
        assertThat(saved.getIncidentDate()).isEqualTo(testClaim.getIncidentDate());
        assertThat(saved.getStatus()).isEqualTo(ClaimStatus.SUBMITTED);

        // Retrieve and verify
        Optional<Claim> retrieved = repository.findById(saved.getId());
        assertThat(retrieved).isPresent();
        assertThat(retrieved.get()).isEqualTo(saved);
    }

    @Test
    @DisplayName("Should find all Claim entities")
    void shouldFindAll() {
        // Given
        Claim claim1 = repository.save(testClaim);
        Claim claim2 = repository.save(createTestClaim(2, "POL-2025-000002"));

        // When
        List<Claim> all = repository.findAll();

        // Then
        assertThat(all).hasSizeGreaterThanOrEqualTo(2);
        assertThat(all).contains(claim1, claim2);
    }

    @Test
    @DisplayName("Should delete Claim by ID")
    void shouldDeleteById() {
        // Given
        Claim saved = repository.save(testClaim);
        Long id = saved.getId();

        // When
        repository.deleteById(id);

        // Then
        Optional<Claim> retrieved = repository.findById(id);
        assertThat(retrieved).isEmpty();
    }

    @Test
    @DisplayName("Should check if Claim exists by ID")
    void shouldCheckExistence() {
        // Given
        Claim saved = repository.save(testClaim);

        // When / Then
        assertThat(repository.existsById(saved.getId())).isTrue();
        assertThat(repository.existsById(999999L)).isFalse();
    }

    @Test
    @DisplayName("Should return empty Optional when entity not found")
    void shouldReturnEmptyWhenNotFound() {
        // When
        Optional<Claim> retrieved = repository.findById(999999L);

        // Then
        assertThat(retrieved).isEmpty();
    }

    @Test
    @DisplayName("Should find claim by claim number")
    void shouldFindByClaimNumber() {
        // Given
        Claim saved = repository.save(testClaim);

        // When
        Optional<Claim> found = repository.findByClaimNumber(saved.getClaimNumber());

        // Then
        assertThat(found).isPresent();
        assertThat(found.get().getClaimNumber()).isEqualTo(saved.getClaimNumber());
    }

    @Test
    @DisplayName("Should find claims by status")
    void shouldFindByStatus() {
        // Given
        Claim submittedClaim = repository.save(testClaim);
        Claim reviewClaim = repository.save(createTestClaim(2, "POL-2025-000002"));
        reviewClaim.moveToUnderReview();
        repository.save(reviewClaim);

        // When
        List<Claim> submittedClaims = repository.findByStatus(ClaimStatus.SUBMITTED);
        List<Claim> reviewClaims = repository.findByStatus(ClaimStatus.UNDER_REVIEW);

        // Then
        assertThat(submittedClaims).isNotEmpty();
        assertThat(submittedClaims).contains(submittedClaim);
        assertThat(reviewClaims).isNotEmpty();
        assertThat(reviewClaims).contains(reviewClaim);
    }

    @Test
    @DisplayName("Should find claims by policy ID")
    void shouldFindByPolicyId() {
        // Given
        String policyId = "POL-2025-000001";
        Claim claim1 = repository.save(createTestClaim(1, policyId));
        Claim claim2 = repository.save(createTestClaim(2, policyId));
        repository.save(createTestClaim(3, "POL-2025-000002")); // Different policy

        // When
        List<Claim> claims = repository.findByPolicyId(policyId);

        // Then
        assertThat(claims).hasSize(2);
        assertThat(claims).contains(claim1, claim2);
    }

    @Test
    @DisplayName("Should update claim status")
    void shouldUpdateClaimStatus() {
        // Given
        Claim saved = repository.save(testClaim);
        assertThat(saved.getStatus()).isEqualTo(ClaimStatus.SUBMITTED);

        // When
        saved.moveToUnderReview();
        Claim updated = repository.save(saved);

        // Then
        assertThat(updated.getStatus()).isEqualTo(ClaimStatus.UNDER_REVIEW);

        // Verify persistence
        Optional<Claim> retrieved = repository.findById(updated.getId());
        assertThat(retrieved).isPresent();
        assertThat(retrieved.get().getStatus()).isEqualTo(ClaimStatus.UNDER_REVIEW);
    }

    @Test
    @DisplayName("Should handle claim lifecycle transitions")
    void shouldHandleClaimLifecycleTransitions() {
        // Given
        Claim saved = repository.save(testClaim);

        // Move to under review
        saved.moveToUnderReview();
        saved = repository.save(saved);
        assertThat(saved.getStatus()).isEqualTo(ClaimStatus.UNDER_REVIEW);

        // Approve
        saved.approve();
        saved = repository.save(saved);
        assertThat(saved.getStatus()).isEqualTo(ClaimStatus.APPROVED);

        // Mark as paid
        saved.markAsPaid();
        saved = repository.save(saved);
        assertThat(saved.getStatus()).isEqualTo(ClaimStatus.PAID);
        assertThat(saved.isInFinalState()).isTrue();
    }

    // Helper method
    private Claim createTestClaim(int sequence, String policyId) {
        ClaimNumber claimNumber = ClaimNumber.generate(2025, sequence);
        ClaimAmount claimedAmount = ClaimAmount.of(BigDecimal.valueOf(5000.00 + (sequence * 100)), "USD");
        LocalDate incidentDate = LocalDate.of(2025, 1, 15);
        return new Claim(claimNumber, claimedAmount, incidentDate, policyId);
    }
}
