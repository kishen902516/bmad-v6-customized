package com.insurance.policy;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.core.importer.ImportOption;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.library.Architectures;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.*;
import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;

/**
 * ArchUnit tests for Clean Architecture compliance.
 *
 * These tests enforce architectural rules and fail the build if violated.
 * Strictness level: standard
 *
 * @author Generated by BMAD Spring Boot Clean Architecture Generator
 * @version 1.0
 */
@DisplayName("Architecture Compliance Tests")
class ArchitectureTest {

    private static JavaClasses classes;

    @BeforeAll
    static void setUp() {
        classes = new ClassFileImporter()
                .withImportOption(ImportOption.Predefined.DO_NOT_INCLUDE_TESTS)
                .importPackages("com.insurance.policy");
    }

    // ========================================================================
    // Layer Dependency Rules
    // ========================================================================

    @Test
    @DisplayName("Clean Architecture: Layer dependencies should be respected")
    void layerDependenciesShouldBeRespected() {
        Architectures.LayeredArchitecture architecture = layeredArchitecture()
                .consideringAllDependencies()

                // Define layers
                .layer("Domain").definedBy("..domain..")
                .layer("Application").definedBy("..application..")
                .layer("Infrastructure").definedBy("..infrastructure..")
                .layer("Presentation").definedBy("..presentation..")

                // Define access rules (Dependency Rule: dependencies point inward)
                .whereLayer("Domain").mayOnlyBeAccessedByLayers("Application", "Infrastructure", "Presentation")
                .whereLayer("Application").mayOnlyBeAccessedByLayers("Infrastructure", "Presentation")
                .whereLayer("Infrastructure").mayNotBeAccessedByAnyLayer()
                .whereLayer("Presentation").mayNotBeAccessedByAnyLayer();

        architecture.check(classes);
    }

    @Test
    @DisplayName("Domain layer: Should have no dependencies on other layers")
    void domainLayerShouldBeIndependent() {
        ArchRule rule = classes()
                .that().resideInAPackage("..domain..")
                .should().onlyDependOnClassesThat()
                .resideInAnyPackage("..domain..", "java..", "org.slf4j..");

        rule.check(classes);
    }

    @Test
    @DisplayName("Application layer: Should only depend on domain")
    void applicationLayerShouldOnlyDependOnDomain() {
        ArchRule rule = classes()
                .that().resideInAPackage("..application..")
                .should().onlyDependOnClassesThat()
                .resideInAnyPackage(
                        "..application..",
                        "..domain..",
                        "java..",
                        "org.slf4j..",
                        "org.springframework.stereotype..",
                        "org.springframework.transaction..",
                        "jakarta.validation.."
                );

        rule.check(classes);
    }

    // ========================================================================
    // Naming Convention Rules
    // ========================================================================

    @Test
    @DisplayName("Repository interfaces: Should reside in domain.port package")
    void repositoryInterfacesShouldBeInDomainPort() {
        ArchRule rule = classes()
                .that().haveSimpleNameEndingWith("Repository")
                .and().areInterfaces()
                .and().haveSimpleNameNotEndingWith("SpringDataRepository")  // Exclude Spring Data repositories
                .should().resideInAPackage("..domain.port")
                .as("Repository interfaces should reside in domain.port package (excluding Spring Data repositories)");

        rule.check(classes);
    }

    @Test
    @DisplayName("Controllers: Should reside in presentation package")
    void controllersShouldBeInPresentation() {
        ArchRule rule = classes()
                .that().haveSimpleNameEndingWith("Controller")
                .should().resideInAPackage("..presentation..");

        rule.check(classes);
    }

    @Test
    @DisplayName("Use cases: Should reside in application.usecase package")
    void useCasesShouldBeInApplicationUseCase() {
        ArchRule rule = classes()
                .that().haveSimpleNameEndingWith("UseCase")
                .and().areInterfaces()
                .should().resideInAPackage("..application.usecase");

        rule.check(classes);
    }

    @Test
    @DisplayName("Services: Should reside in application.service package")
    void servicesShouldBeInApplicationService() {
        ArchRule rule = classes()
                .that().haveSimpleNameEndingWith("Service")
                .should().resideInAPackage("..application.service");

        rule.check(classes);
    }

    // ========================================================================
    // Annotation Rules
    // ========================================================================

    @Test
    @DisplayName("Domain layer: Should have no Spring annotations")
    void domainLayerShouldHaveNoSpringAnnotations() {
        ArchRule rule = noClasses()
                .that().resideInAPackage("..domain..")
                .should().beAnnotatedWith("org.springframework.stereotype.Component")
                .orShould().beAnnotatedWith("org.springframework.stereotype.Service")
                .orShould().beAnnotatedWith("org.springframework.stereotype.Repository");

        rule.check(classes);
    }

    @Test
    @DisplayName("Domain layer: Should have no JPA annotations")
    void domainLayerShouldHaveNoJpaAnnotations() {
        ArchRule rule = noClasses()
                .that().resideInAPackage("..domain..")
                .should().beAnnotatedWith("jakarta.persistence.Entity")
                .orShould().beAnnotatedWith("jakarta.persistence.Table");

        rule.check(classes);
    }

    @Test
    @DisplayName("JPA entities: Should only be in infrastructure layer")
    void jpaEntitiesShouldOnlyBeInInfrastructure() {
        ArchRule rule = classes()
                .that().areAnnotatedWith("jakarta.persistence.Entity")
                .should().resideInAPackage("..infrastructure..");

        rule.check(classes);
    }

    @Test
    @DisplayName("Controllers: Should be annotated with @RestController")
    void controllersShouldBeAnnotatedWithRestController() {
        ArchRule rule = classes()
                .that().haveSimpleNameEndingWith("Controller")
                .and().resideInAPackage("..presentation..")
                .should().beAnnotatedWith("org.springframework.web.bind.annotation.RestController");

        rule.check(classes);
    }

    @Test
    @DisplayName("Services: Should be annotated with @Service")
    void servicesShouldBeAnnotatedWithService() {
        ArchRule rule = classes()
                .that().haveSimpleNameEndingWith("Service")
                .and().resideInAPackage("..application.service")
                .should().beAnnotatedWith("org.springframework.stereotype.Service");

        rule.check(classes);
    }

    // ========================================================================
    // Circular Dependency Rules
    // ========================================================================

    @Test
    @DisplayName("No circular dependencies: Between packages")
    void noCircularDependenciesBetweenPackages() {
        ArchRule rule = slices()
                .matching("com.insurance.policy.(*)..")
                .should().beFreeOfCycles();

        rule.check(classes);
    }
}
