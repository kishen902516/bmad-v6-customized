package com.insurance.policy.application.service;

import com.insurance.policy.application.dto.SubmitClaimInput;
import com.insurance.policy.application.dto.SubmitClaimOutput;
import com.insurance.policy.application.exception.InvalidClaimAmountException;
import com.insurance.policy.application.exception.PolicyNotFoundException;
import com.insurance.policy.domain.entity.Claim;
import com.insurance.policy.domain.entity.Policy;
import com.insurance.policy.domain.port.ClaimRepository;
import com.insurance.policy.domain.port.PolicyRepository;
import com.insurance.policy.domain.valueobject.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Unit tests for SubmitClaimService.
 *
 * Tests use case orchestration logic with mocked dependencies.
 * Verifies business rules and interactions with repositories.
 *
 * @author Generated by BMAD Spring Boot Clean Architecture Generator
 * @version 1.0
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("SubmitClaim Use Case Tests")
class SubmitClaimServiceTest {

    @Mock
    private ClaimRepository claimRepository;

    @Mock
    private PolicyRepository policyRepository;

    private SubmitClaimService service;

    private static final Long VALID_POLICY_ID = 1L;
    private static final BigDecimal VALID_AMOUNT = new BigDecimal("5000.00");
    private static final LocalDate VALID_INCIDENT_DATE = LocalDate.now().minusDays(7);
    private static final String VALID_DESCRIPTION = "Car accident on highway - rear-end collision";
    private static final String VALID_CURRENCY = "USD";

    @BeforeEach
    void setUp() {
        service = new SubmitClaimService(claimRepository, policyRepository);
    }

    @Test
    @DisplayName("Should submit claim successfully with valid input")
    void shouldSubmitClaimSuccessfully() {
        // Given
        SubmitClaimInput input = new SubmitClaimInput(
            VALID_POLICY_ID,
            VALID_AMOUNT,
            VALID_INCIDENT_DATE,
            VALID_DESCRIPTION,
            VALID_CURRENCY
        );

        Policy mockPolicy = createActivePolicy(VALID_POLICY_ID);
        when(policyRepository.findById(VALID_POLICY_ID)).thenReturn(Optional.of(mockPolicy));

        Claim savedClaim = createClaim(1L, "CLM-2025-000001");
        when(claimRepository.findAll()).thenReturn(Collections.emptyList());
        when(claimRepository.save(any(Claim.class))).thenReturn(savedClaim);

        // When
        SubmitClaimOutput output = service.execute(input);

        // Then
        assertThat(output).isNotNull();
        assertThat(output.claimId()).isEqualTo(1L);
        assertThat(output.claimNumber()).isEqualTo("CLM-2025-000001");
        assertThat(output.status()).isEqualTo("SUBMITTED");
        assertThat(output.submittedAt()).isNotNull();

        // Verify repository interactions
        verify(policyRepository).findById(VALID_POLICY_ID);
        verify(claimRepository).findAll();

        ArgumentCaptor<Claim> claimCaptor = ArgumentCaptor.forClass(Claim.class);
        verify(claimRepository).save(claimCaptor.capture());

        Claim capturedClaim = claimCaptor.getValue();
        assertThat(capturedClaim.getClaimedAmount().amount()).isEqualByComparingTo(VALID_AMOUNT);
        assertThat(capturedClaim.getIncidentDate()).isEqualTo(VALID_INCIDENT_DATE);
        assertThat(capturedClaim.getStatus()).isEqualTo(ClaimStatus.SUBMITTED);
    }

    @Test
    @DisplayName("Should throw PolicyNotFoundException when policy does not exist")
    void shouldThrowExceptionWhenPolicyNotFound() {
        // Given
        SubmitClaimInput input = new SubmitClaimInput(
            999L,
            VALID_AMOUNT,
            VALID_INCIDENT_DATE,
            VALID_DESCRIPTION,
            VALID_CURRENCY
        );

        when(policyRepository.findById(999L)).thenReturn(Optional.empty());

        // When / Then
        assertThatThrownBy(() -> service.execute(input))
                .isInstanceOf(PolicyNotFoundException.class)
                .hasMessageContaining("Policy with ID 999 not found");

        verify(policyRepository).findById(999L);
        verifyNoInteractions(claimRepository);
    }

    @Test
    @DisplayName("Should throw IllegalStateException when policy is not active")
    void shouldThrowExceptionWhenPolicyNotActive() {
        // Given
        SubmitClaimInput input = new SubmitClaimInput(
            VALID_POLICY_ID,
            VALID_AMOUNT,
            VALID_INCIDENT_DATE,
            VALID_DESCRIPTION,
            VALID_CURRENCY
        );

        Policy inactivePolicy = createInactivePolicy(VALID_POLICY_ID);
        when(policyRepository.findById(VALID_POLICY_ID)).thenReturn(Optional.of(inactivePolicy));

        // When / Then
        assertThatThrownBy(() -> service.execute(input))
                .isInstanceOf(IllegalStateException.class)
                .hasMessageContaining("Cannot submit claim for inactive policy");

        verify(policyRepository).findById(VALID_POLICY_ID);
        verifyNoInteractions(claimRepository);
    }

    @Test
    @DisplayName("Should throw InvalidClaimAmountException when amount is zero")
    void shouldThrowExceptionWhenAmountIsZero() {
        // Given
        SubmitClaimInput input = new SubmitClaimInput(
            VALID_POLICY_ID,
            BigDecimal.ZERO,
            VALID_INCIDENT_DATE,
            VALID_DESCRIPTION,
            VALID_CURRENCY
        );

        Policy mockPolicy = createActivePolicy(VALID_POLICY_ID);
        when(policyRepository.findById(VALID_POLICY_ID)).thenReturn(Optional.of(mockPolicy));

        // When / Then
        assertThatThrownBy(() -> service.execute(input))
                .isInstanceOf(InvalidClaimAmountException.class)
                .hasMessageContaining("Claimed amount must be greater than zero");

        verify(policyRepository).findById(VALID_POLICY_ID);
        verifyNoInteractions(claimRepository);
    }

    @Test
    @DisplayName("Should throw InvalidClaimAmountException when amount is negative")
    void shouldThrowExceptionWhenAmountIsNegative() {
        // Given
        SubmitClaimInput input = new SubmitClaimInput(
            VALID_POLICY_ID,
            new BigDecimal("-100.00"),
            VALID_INCIDENT_DATE,
            VALID_DESCRIPTION,
            VALID_CURRENCY
        );

        Policy mockPolicy = createActivePolicy(VALID_POLICY_ID);
        when(policyRepository.findById(VALID_POLICY_ID)).thenReturn(Optional.of(mockPolicy));

        // When / Then
        assertThatThrownBy(() -> service.execute(input))
                .isInstanceOf(InvalidClaimAmountException.class)
                .hasMessageContaining("Claimed amount must be greater than zero");

        verify(policyRepository).findById(VALID_POLICY_ID);
        verifyNoInteractions(claimRepository);
    }

    @Test
    @DisplayName("Should throw InvalidClaimAmountException when amount is null")
    void shouldThrowExceptionWhenAmountIsNull() {
        // Given
        SubmitClaimInput input = new SubmitClaimInput(
            VALID_POLICY_ID,
            null,
            VALID_INCIDENT_DATE,
            VALID_DESCRIPTION,
            VALID_CURRENCY
        );

        Policy mockPolicy = createActivePolicy(VALID_POLICY_ID);
        when(policyRepository.findById(VALID_POLICY_ID)).thenReturn(Optional.of(mockPolicy));

        // When / Then
        assertThatThrownBy(() -> service.execute(input))
                .isInstanceOf(InvalidClaimAmountException.class)
                .hasMessageContaining("Claimed amount must be greater than zero");

        verify(policyRepository).findById(VALID_POLICY_ID);
        verifyNoInteractions(claimRepository);
    }

    @Test
    @DisplayName("Should generate unique claim numbers for multiple claims")
    void shouldGenerateUniqueClaimNumbers() {
        // Given
        SubmitClaimInput input = new SubmitClaimInput(
            VALID_POLICY_ID,
            VALID_AMOUNT,
            VALID_INCIDENT_DATE,
            VALID_DESCRIPTION,
            VALID_CURRENCY
        );

        Policy mockPolicy = createActivePolicy(VALID_POLICY_ID);
        when(policyRepository.findById(VALID_POLICY_ID)).thenReturn(Optional.of(mockPolicy));

        // Simulate existing claims
        Claim existingClaim = createClaim(100L, "CLM-2025-000001");
        when(claimRepository.findAll()).thenReturn(List.of(existingClaim));

        Claim savedClaim = createClaim(2L, "CLM-2025-000002");
        when(claimRepository.save(any(Claim.class))).thenReturn(savedClaim);

        // When
        SubmitClaimOutput output = service.execute(input);

        // Then
        assertThat(output.claimNumber()).isEqualTo("CLM-2025-000002");

        verify(claimRepository).findAll();
        verify(claimRepository).save(any(Claim.class));
    }

    @Test
    @DisplayName("Should handle repository exceptions gracefully")
    void shouldHandleRepositoryExceptions() {
        // Given
        SubmitClaimInput input = new SubmitClaimInput(
            VALID_POLICY_ID,
            VALID_AMOUNT,
            VALID_INCIDENT_DATE,
            VALID_DESCRIPTION,
            VALID_CURRENCY
        );

        when(policyRepository.findById(VALID_POLICY_ID))
                .thenThrow(new RuntimeException("Database connection error"));

        // When / Then
        assertThatThrownBy(() -> service.execute(input))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("Database connection error");
    }

    @Test
    @DisplayName("Should save claim with correct currency")
    void shouldSaveClaimWithCorrectCurrency() {
        // Given
        SubmitClaimInput input = new SubmitClaimInput(
            VALID_POLICY_ID,
            VALID_AMOUNT,
            VALID_INCIDENT_DATE,
            VALID_DESCRIPTION,
            "EUR"
        );

        Policy mockPolicy = createActivePolicy(VALID_POLICY_ID);
        when(policyRepository.findById(VALID_POLICY_ID)).thenReturn(Optional.of(mockPolicy));

        Claim savedClaim = createClaimWithCurrency(1L, "CLM-2025-000001", "EUR");
        when(claimRepository.findAll()).thenReturn(Collections.emptyList());
        when(claimRepository.save(any(Claim.class))).thenReturn(savedClaim);

        // When
        SubmitClaimOutput output = service.execute(input);

        // Then
        assertThat(output).isNotNull();

        ArgumentCaptor<Claim> claimCaptor = ArgumentCaptor.forClass(Claim.class);
        verify(claimRepository).save(claimCaptor.capture());

        Claim capturedClaim = claimCaptor.getValue();
        assertThat(capturedClaim.getClaimedAmount().currency()).isEqualTo("EUR");
    }

    // Helper methods to create test objects

    private Policy createActivePolicy(Long id) {
        Coverage coverage = Coverage.of("AUTO", 1000.0, "USD");
        // Create policy with future effective date (required by business rule)
        Policy policy = new Policy(
            "CUST-12345",
            LocalDate.now().plusDays(1),
            List.of(coverage)
        );
        setIdUsingReflection(policy, id, Policy.class);
        // Set effective date to today using reflection so we can activate it
        setFieldUsingReflection(policy, "effectiveDate", LocalDate.now(), Policy.class);
        // Activate the policy
        policy.activate();
        return policy;
    }

    private Policy createInactivePolicy(Long id) {
        Coverage coverage = Coverage.of("AUTO", 1000.0, "USD");
        Policy policy = new Policy(
            "CUST-12345",
            LocalDate.now().plusDays(1),
            List.of(coverage)
        );
        setIdUsingReflection(policy, id, Policy.class);
        // Leave in DRAFT status (not active)
        return policy;
    }

    private Claim createClaim(Long id, String claimNumberValue) {
        ClaimNumber claimNumber = ClaimNumber.of(claimNumberValue);
        ClaimAmount claimAmount = ClaimAmount.of(VALID_AMOUNT, VALID_CURRENCY);
        Claim claim = new Claim(
            claimNumber,
            claimAmount,
            VALID_INCIDENT_DATE,
            VALID_POLICY_ID.toString()
        );
        setIdUsingReflection(claim, id, Claim.class);
        return claim;
    }

    private Claim createClaimWithCurrency(Long id, String claimNumberValue, String currency) {
        ClaimNumber claimNumber = ClaimNumber.of(claimNumberValue);
        ClaimAmount claimAmount = ClaimAmount.of(VALID_AMOUNT, currency);
        Claim claim = new Claim(
            claimNumber,
            claimAmount,
            VALID_INCIDENT_DATE,
            VALID_POLICY_ID.toString()
        );
        setIdUsingReflection(claim, id, Claim.class);
        return claim;
    }

    /**
     * Helper method to set ID field using reflection.
     * This is necessary because setId() is package-private.
     */
    private <T> void setIdUsingReflection(T entity, Long id, Class<T> clazz) {
        try {
            var idField = clazz.getDeclaredField("id");
            idField.setAccessible(true);
            idField.set(entity, id);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new RuntimeException("Failed to set ID using reflection", e);
        }
    }

    /**
     * Helper method to set any field using reflection.
     */
    private <T> void setFieldUsingReflection(T entity, String fieldName, Object value, Class<T> clazz) {
        try {
            var field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(entity, value);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new RuntimeException("Failed to set field using reflection", e);
        }
    }
}
