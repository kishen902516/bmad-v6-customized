package com.insurance.policy.domain.entity;

import com.insurance.policy.domain.valueobject.ClaimAmount;
import com.insurance.policy.domain.valueobject.ClaimNumber;
import com.insurance.policy.domain.valueobject.ClaimStatus;
import java.time.LocalDate;

/**
 * Claim domain entity representing an insurance claim.
 *
 * This is a domain entity following Clean Architecture principles.
 * It contains business logic and enforces invariants.
 * It has no framework dependencies (no JPA annotations).
 *
 * @author Generated by BMAD Spring Boot Clean Architecture Generator
 * @version 1.0
 */
public class Claim {

    private Long id;
    private ClaimNumber claimNumber;
    private ClaimAmount claimedAmount;
    private LocalDate incidentDate;
    private ClaimStatus status;
    private LocalDate submittedDate;
    private String policyId;

    /**
     * Constructor with required fields.
     * Enforces invariants and validates input.
     *
     * @param claimNumber the unique claim identifier
     * @param claimedAmount the amount being claimed
     * @param incidentDate when the incident occurred
     * @param policyId the associated policy ID
     * @throws IllegalArgumentException if validation fails
     */
    public Claim(ClaimNumber claimNumber, ClaimAmount claimedAmount, LocalDate incidentDate, String policyId) {
        validateClaimNumber(claimNumber);
        validateClaimedAmount(claimedAmount);
        validateIncidentDate(incidentDate);
        validatePolicyId(policyId);

        this.claimNumber = claimNumber;
        this.claimedAmount = claimedAmount;
        this.incidentDate = incidentDate;
        this.policyId = policyId;
        this.status = ClaimStatus.SUBMITTED;
        this.submittedDate = LocalDate.now();
    }

    /**
     * Default constructor for ORM frameworks.
     * Should not be used in business logic.
     */
    protected Claim() {
        // For ORM frameworks only
    }

    // Business Methods

    /**
     * Move the claim to under review status.
     * Only submitted claims can be moved to under review.
     *
     * @throws IllegalStateException if claim is not in SUBMITTED status
     */
    public void moveToUnderReview() {
        if (status != ClaimStatus.SUBMITTED) {
            throw new IllegalStateException("Can only review claims in SUBMITTED status");
        }
        this.status = ClaimStatus.UNDER_REVIEW;
    }

    /**
     * Approve the claim.
     * Only claims under review can be approved.
     *
     * @throws IllegalStateException if claim is not in UNDER_REVIEW status
     */
    public void approve() {
        if (status != ClaimStatus.UNDER_REVIEW) {
            throw new IllegalStateException("Can only approve claims in UNDER_REVIEW status");
        }
        this.status = ClaimStatus.APPROVED;
    }

    /**
     * Reject the claim.
     * Only claims under review can be rejected.
     *
     * @throws IllegalStateException if claim is not in UNDER_REVIEW status
     */
    public void reject() {
        if (status != ClaimStatus.UNDER_REVIEW) {
            throw new IllegalStateException("Can only reject claims in UNDER_REVIEW status");
        }
        this.status = ClaimStatus.REJECTED;
    }

    /**
     * Mark the claim as paid.
     * Only approved claims can be marked as paid.
     *
     * @throws IllegalStateException if claim is not in APPROVED status
     */
    public void markAsPaid() {
        if (status != ClaimStatus.APPROVED) {
            throw new IllegalStateException("Can only mark approved claims as paid");
        }
        this.status = ClaimStatus.PAID;
    }

    /**
     * Check if the claim can be processed for payment.
     *
     * @return true if claim is approved and not yet paid
     */
    public boolean canBeProcessedForPayment() {
        return status == ClaimStatus.APPROVED;
    }

    /**
     * Check if the claim is in a final state (paid or rejected).
     *
     * @return true if claim is paid or rejected
     */
    public boolean isInFinalState() {
        return status == ClaimStatus.PAID || status == ClaimStatus.REJECTED;
    }

    // Private validation methods

    private void validateClaimNumber(ClaimNumber claimNumber) {
        if (claimNumber == null) {
            throw new IllegalArgumentException("Claim number is required");
        }
    }

    private void validateClaimedAmount(ClaimAmount claimedAmount) {
        if (claimedAmount == null) {
            throw new IllegalArgumentException("Claimed amount is required");
        }
        if (claimedAmount.isZero()) {
            throw new IllegalArgumentException("Claimed amount must be greater than zero");
        }
    }

    private void validateIncidentDate(LocalDate incidentDate) {
        if (incidentDate == null) {
            throw new IllegalArgumentException("Incident date is required");
        }
        if (incidentDate.isAfter(LocalDate.now())) {
            throw new IllegalArgumentException("Incident date cannot be in the future");
        }
    }

    private void validatePolicyId(String policyId) {
        if (policyId == null || policyId.trim().isEmpty()) {
            throw new IllegalArgumentException("Policy ID is required");
        }
    }

    // Getters

    public Long getId() {
        return id;
    }

    public ClaimNumber getClaimNumber() {
        return claimNumber;
    }

    public ClaimAmount getClaimedAmount() {
        return claimedAmount;
    }

    public LocalDate getIncidentDate() {
        return incidentDate;
    }

    public ClaimStatus getStatus() {
        return status;
    }

    public LocalDate getSubmittedDate() {
        return submittedDate;
    }

    public String getPolicyId() {
        return policyId;
    }

    // Package-private setters (for ORM)

    void setId(Long id) {
        this.id = id;
    }

    void setSubmittedDate(LocalDate submittedDate) {
        this.submittedDate = submittedDate;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Claim claim = (Claim) o;
        return id != null && id.equals(claim.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }

    @Override
    public String toString() {
        return "Claim{" +
                "id=" + id +
                ", claimNumber=" + claimNumber +
                ", claimedAmount=" + claimedAmount +
                ", incidentDate=" + incidentDate +
                ", status=" + status +
                ", policyId='" + policyId + '\'' +
                '}';
    }
}
