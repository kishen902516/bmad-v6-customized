package com.insurance.policy.presentation.rest;

import com.insurance.policy.application.dto.SubmitClaimInput;
import com.insurance.policy.application.dto.SubmitClaimOutput;
import com.insurance.policy.application.usecase.SubmitClaimUseCase;
import com.insurance.policy.presentation.rest.model.ClaimResponse;
import com.insurance.policy.presentation.rest.model.CreateClaimRequest;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;

/**
 * REST Controller for Claim operations.
 *
 * Handles HTTP requests related to insurance claims and delegates to use cases.
 * Part of the presentation layer in Clean Architecture.
 *
 * This controller is thin and focused on HTTP concerns only:
 * - Request/response mapping
 * - HTTP status codes
 * - Request validation
 * - Location header generation
 *
 * Business logic is handled by the use case layer.
 *
 * @author Generated by BMAD Spring Boot Clean Architecture Generator
 */
@RestController
@RequestMapping("/api/v1/claims")
@Tag(
    name = "Claims",
    description = "Insurance claim management APIs. Submit, track, and manage insurance claims."
)
public class ClaimController {

    private static final Logger log = LoggerFactory.getLogger(ClaimController.class);

    private final SubmitClaimUseCase submitClaimUseCase;

    /**
     * Constructor injection for dependencies.
     *
     * @param submitClaimUseCase the use case for submitting claims
     */
    public ClaimController(SubmitClaimUseCase submitClaimUseCase) {
        this.submitClaimUseCase = submitClaimUseCase;
    }

    /**
     * Submit a new insurance claim.
     *
     * This endpoint accepts a claim submission request, validates it,
     * and delegates to the use case layer for processing.
     *
     * @param request the claim request containing policy ID, amount, incident details
     * @return ResponseEntity with ClaimResponse and 201 Created status
     */
    @PostMapping
    @Operation(
        summary = "Submit a new insurance claim",
        description = "Submits a new claim for an existing policy. The claim will be validated " +
                      "against business rules (policy exists and is active, amount is valid, " +
                      "incident date is valid) before being persisted. A unique claim number " +
                      "will be auto-generated in format CLM-YYYY-NNNNNN."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "201",
            description = "Claim submitted successfully. Returns the claim details with auto-generated claim number.",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ClaimResponse.class)
            )
        ),
        @ApiResponse(
            responseCode = "400",
            description = "Invalid request data. This can occur when:\n" +
                          "- Required fields are missing\n" +
                          "- Validation constraints are violated (e.g., negative amount)\n" +
                          "- Business rules are violated (e.g., incident date in future)\n" +
                          "- Claimed amount exceeds limits",
            content = @Content(mediaType = "application/json")
        ),
        @ApiResponse(
            responseCode = "404",
            description = "Policy not found. The specified policy ID does not exist in the system.",
            content = @Content(mediaType = "application/json")
        ),
        @ApiResponse(
            responseCode = "409",
            description = "Conflict. The claim cannot be submitted due to business state constraints " +
                          "(e.g., policy is not active, policy has reached claim limits).",
            content = @Content(mediaType = "application/json")
        ),
        @ApiResponse(
            responseCode = "500",
            description = "Internal server error. An unexpected error occurred while processing the claim.",
            content = @Content(mediaType = "application/json")
        )
    })
    public ResponseEntity<ClaimResponse> submitClaim(
            @Valid @RequestBody CreateClaimRequest request) {

        log.info("Received request to submit claim for policy: {}", request.policyId());

        // Convert REST request to use case input
        // This separation allows the API contract to evolve independently from business logic
        SubmitClaimInput input = new SubmitClaimInput(
            request.policyId(),
            request.claimedAmount(),
            request.incidentDate(),
            request.description(),
            request.currency()
        );

        // Execute use case - all business logic happens here
        SubmitClaimOutput output = submitClaimUseCase.execute(input);

        // Convert use case output to REST response
        ClaimResponse response = ClaimResponse.from(
            output,
            request.policyId(),
            request.claimedAmount()
        );

        // Generate Location header with the URI of the created resource
        URI location = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .path("/{id}")
            .buildAndExpand(response.claimId())
            .toUri();

        log.info("Claim submitted successfully: {} for policy: {}",
                 response.claimNumber(), request.policyId());

        // Return 201 Created with Location header
        return ResponseEntity
            .created(location)
            .body(response);
    }

    /**
     * Health check endpoint for the Claims API.
     *
     * @return ResponseEntity with status message
     */
    @GetMapping("/health")
    @Operation(
        summary = "Health check",
        description = "Simple health check endpoint to verify the Claims API is running"
    )
    @ApiResponse(responseCode = "200", description = "Service is healthy")
    public ResponseEntity<String> health() {
        return ResponseEntity.ok("Claims Service is running");
    }
}
