package com.insurance.policy.application.service;

import com.insurance.policy.application.dto.SubmitClaimInput;
import com.insurance.policy.application.dto.SubmitClaimOutput;
import com.insurance.policy.application.exception.InvalidClaimAmountException;
import com.insurance.policy.application.exception.PolicyNotFoundException;
import com.insurance.policy.application.usecase.SubmitClaimUseCase;
import com.insurance.policy.domain.entity.Claim;
import com.insurance.policy.domain.entity.Policy;
import com.insurance.policy.domain.port.ClaimRepository;
import com.insurance.policy.domain.port.PolicyRepository;
import com.insurance.policy.domain.valueobject.ClaimAmount;
import com.insurance.policy.domain.valueobject.ClaimNumber;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.Year;
import java.util.List;

/**
 * Service implementation of SubmitClaim use case.
 *
 * This service orchestrates the claim submission process:
 * 1. Validates that the policy exists and is active
 * 2. Validates the claimed amount
 * 3. Generates a unique claim number
 * 4. Creates and persists the claim entity
 * 5. Returns the claim details
 *
 * Resides in the application layer as part of Clean Architecture.
 *
 * @author Generated by BMAD Spring Boot Clean Architecture Generator
 * @version 1.0
 */
@Service
@Transactional
public class SubmitClaimService implements SubmitClaimUseCase {

    private static final Logger log = LoggerFactory.getLogger(SubmitClaimService.class);

    private final ClaimRepository claimRepository;
    private final PolicyRepository policyRepository;

    /**
     * Constructor with dependency injection.
     */
    public SubmitClaimService(ClaimRepository claimRepository, PolicyRepository policyRepository) {
        this.claimRepository = claimRepository;
        this.policyRepository = policyRepository;
    }

    @Override
    public SubmitClaimOutput execute(SubmitClaimInput input) {
        log.debug("Submitting claim for policy ID: {}", input.policyId());

        // Step 1: Validate policy exists
        Policy policy = validatePolicyExists(input.policyId());

        // Step 2: Validate policy is active
        validatePolicyIsActive(policy);

        // Step 3: Validate claimed amount
        validateClaimedAmount(input.claimedAmount());

        // Step 4: Generate unique claim number
        ClaimNumber claimNumber = generateClaimNumber();

        // Step 5: Create Claim entity
        ClaimAmount claimAmount = ClaimAmount.of(input.claimedAmount(), input.currency());
        Claim claim = new Claim(
            claimNumber,
            claimAmount,
            input.incidentDate(),
            policy.getId().toString()
        );

        // Step 6: Persist the claim
        Claim savedClaim = claimRepository.save(claim);

        log.info("Claim submitted successfully: {} for policy ID: {}",
                 savedClaim.getClaimNumber(), input.policyId());

        // Step 7: Return output
        return SubmitClaimOutput.from(savedClaim);
    }

    /**
     * Validates that the policy exists.
     *
     * @param policyId the policy ID to validate
     * @return the Policy if found
     * @throws PolicyNotFoundException if policy not found
     */
    private Policy validatePolicyExists(Long policyId) {
        return policyRepository.findById(policyId)
                .orElseThrow(() -> {
                    log.error("Policy not found: {}", policyId);
                    return new PolicyNotFoundException(policyId);
                });
    }

    /**
     * Validates that the policy is active.
     * A policy must be in ACTIVE status to accept claims.
     *
     * @param policy the policy to validate
     * @throws IllegalStateException if policy is not active
     */
    private void validatePolicyIsActive(Policy policy) {
        if (!policy.isActive()) {
            log.error("Cannot submit claim - policy is not active: {} (status: {})",
                     policy.getId(), policy.getStatus());
            throw new IllegalStateException(
                String.format("Cannot submit claim for inactive policy. Policy ID: %d, Status: %s",
                             policy.getId(), policy.getStatus()));
        }
    }

    /**
     * Validates that the claimed amount is positive.
     *
     * @param claimedAmount the amount to validate
     * @throws InvalidClaimAmountException if amount is zero or negative
     */
    private void validateClaimedAmount(BigDecimal claimedAmount) {
        if (claimedAmount == null || claimedAmount.compareTo(BigDecimal.ZERO) <= 0) {
            log.error("Invalid claim amount: {}", claimedAmount);
            throw new InvalidClaimAmountException(
                "Claimed amount must be greater than zero", claimedAmount);
        }
    }

    /**
     * Generates a unique claim number in format CLM-YYYY-NNNNNN.
     *
     * The sequence number is determined by counting existing claims in the current year
     * and incrementing by 1.
     *
     * @return a new ClaimNumber
     */
    private ClaimNumber generateClaimNumber() {
        int currentYear = Year.now().getValue();

        // Get all claims to determine next sequence number
        // In a production system, this would use a database sequence or counter
        List<Claim> allClaims = claimRepository.findAll();

        // Count claims from current year
        long currentYearClaimsCount = allClaims.stream()
                .filter(c -> c.getClaimNumber().value().startsWith("CLM-" + currentYear))
                .count();

        int nextSequence = (int) currentYearClaimsCount + 1;

        ClaimNumber claimNumber = ClaimNumber.generate(currentYear, nextSequence);
        log.debug("Generated claim number: {}", claimNumber);

        return claimNumber;
    }
}
